---
title: "INTERFACES"
author: "Fred Agbo"
date: February 16, 2026
format:
  revealjs:
    chalkboard: true
    slide-number: true
    code-line-numbers: true   # optional global numbering
---
## Announcements
- Welcome to week 6!
- Grading for PS0.1, PS1, & PS2 are all published.
    - Check in with me if you have any questions on the grades/commnets.
- Week 6 assignment (Problem set 3) is posted and will be due on __Wednesday at 10pm__

## Learning Objectives

- Develop an interface for a given collection type
- Implement multiple classes that conform to the interface of a collection type
- Assess the tradeoffs in running time and memory usage of multiple implementations of a given collection type
- Implement a basic iterator


## Developing an Interface
:::{.smaller style="font-size: 33px;"}

- An **interface** defines a set of methods and behaviors that a class must implement, without specifying how these methods are implemented.
<!-- - In Python, interfaces are often represented using abstract base classes (ABCs) from the `abc` module. -->
- When you run Python’s help function to obtain information about a module, data type, method, or function,
    - You are accessing documentation about that resource’s interface
- Interfaces are concise and informative:
    - They allow you to grasp the behavior of a resource
- In this section, you will develop the interface for a simple collection type called a `bag`:
    - A bag interface allows clients to use bags effectively and allows implementers to produce new classes that implement this interface
:::

## Designing the Bag Interface
:::{.incremental style="font-size: 33px;"}
- Derive an interface from thinking about what bags can do in a real-world situation:
    - A bag can contain any objects
- You will want to know the following:
    - How many things are in a bag
    - How to add things to it or remove them from it
    - Whether a bag is empty
    - How to empty a bag in a single operation
    - How to determine whether a given item is in a bag
    - How to view each item in a bag without emptying it
    - How to create a bag
:::

## Designing the Bag Interface
:::{.smaller style="font-size: 33px;"}
- The next step is to draw up a list of function names, method names, and operator symbols that meet the descriptions of these operations
- Examples include:

        - add
        - clear
        - count
        - for ...
        - in
        - isEmpty
        - len
        - remove
        - str
        - +
        - ==

:::

## Specifying Arguments and Return Values 
:::{.smaller style="font-size: 30px;"}
- Next, add arguments to the operations in the interface
    - And think about what values, if any, they return
- Below, variables `b` and `c` refer to bags

```{.python}
b.clear()	  		        # Make the bag empty
for item in range(10):	    # Add 10 numbers to it
    b.add(item)
print(b)	  		        # Print the contents (a string)
print(4 in b)	     		# Is 4 in the bag?
print(b.count(2))	    	# 1 instance of 2 in the bag
c = b + b	 		        # Contents replicated in a new bag
print(len(c))	     		# 20 numbers
for item in c:	    		# Print them all individually
    print(item)
for item in range(10):      # Remove half of them
    c.remove(item)
print(c == b)	  		    #Should be the same contents now

```
:::

## Arguments for Bag Operations and Their Methods
:::{.smaller style="font-size: 23px;"}

| User’s Bag Operation      | Method in a Bag Class                      |
|--------------------------|--------------------------------------------|
| b = <class name>(<optional collection>) | __init__(self, sourceCollection=None)   |
| b.add(item)              | `add(self, item)`                            |
| b.clear()                | `clear(self)`                                |
| b.count(item)            | `count(self, item) `                         |
| b.isEmpty()              | `isEmpty(self) `                             |
| b.remove(item)           | `remove(self, item) `                        |
| len(b)                   | `__len__(self)`                              |
| str(b)                   | `__str__(self)`                              |
| for item in b            | `__iter__(self)`.                             |
| item in b                | `__contains__(self, item)`       Not needed if `__iter__` is included             |
| b1 + b2                  | `__add__(self, other) `                      |
| b == anyObject           | `__eq__(self, other)`                        |

:::

## Constructors and Implementing Classes
:::{.smaller style="font-size: 30px;"}
- The first row in table above shows an operation that is the constructor for the particular type of bag being created
- The syntactic form `<class name>` is used in the table to indicate that this can be the name of any implementing bag class:
    - The method in the right column is always named `_init_`
- An example of code segment that creates an empty linked bag and an array bag that contains the numbers in a given list is as shown:

```{.python}
from arraybag import ArrayBag
from linkedbag import LinkedBag
 
bag1 = LinkedBag()
bag2 = ArrayBag([20, 60, 100, 43])
```
:::

## Constructors and Implementing Classes
:::{.smaller style="font-size: 30px;"}
-   Final step before expressing an interface in code:
    - describe clearly and concisely what each method does
    - include not only what you expect to occur under normal conditions but also what will happen when something abnormal, such as an error, occurs
- A more detailed form of documentation can include __preconditions__ and __postconditions__:
    -  Precondition is a statement of what must be true for a method to perform its actions correctly
    - Postcondition states what will be true after the method completes execution, assuming that its preconditions are also true:
        - Usually included in __mutator methods__, which modify the internal state of an object

:::

## Exceptions and Documentation 

- Documentation in an interface should include a statement of any exceptions that could be raised:
    - Example, a bag’s `remove` method might raise a `KeyError` if the target item is not in the bag
- A Python method header for the `remove` method:
```{.python}
def remove(self, item):
"""Precondition: item is in self.
Raises: KeyError if item in  not in self.
   Postcondition: item is removed from self."""

```

## Coding an Interface in Python 
- To create an interface, list each of the method headers with its documentation and complete each method with a single `pass` or `return` statement:
    - A `pass` statement is used in the mutator methods that return no value, whereas each accessor method returns a simple default value, such as `False`, `0`, or `None`
- So method headers can be checked with the compiler
    - You may place them within a class whose suffix is “Interface”

## BagInterface in Python 
```{.python}
"""
File: baginterface.py
Author: Ken Lambert
"""
 
class BagInterface(object):
    """Interface for all bag types."""
 
    # Constructor
    def __init__(self, sourceCollection = None):
        """Sets the initial state of self, which includes the
        contents of sourceCollection, if it’s present."""
        pass
 
    # Accessor methods
    def isEmpty(self):
        """Returns True if len(self) == 0,
        or False otherwise."""
        return True
 
    def __len__(self):
        """Returns the number of items in self."""
        return 0
 
    def __str__(self):
        """Returns the string representation of self."""
        return ""
 
    def __iter__(self):
        """Supports iteration over a view of self."""
        return None
    def __add__(self, other):
        """Returns a new bag containing the contents
        of self and other."""
        return None
 
    def __eq__(self, other):
        """Returns True if self equals other,
        or False otherwise."""
        return False
     
    def count(self, item):
        """Returns the number of instances of item in self."""
        return 0
 
    # Mutator methods
    def clear(self):
        """Makes self become empty."""
        pass
 
    def add(self, item):
        """Adds item to self."""
        pass
 
    def remove(self, item):
        """Precondition: item is in self.
        Raises: KeyError if item in not in self.
        Postcondition: item is removed from self."""
        pass

```


## Array-Based BagInterface Implementation
:::{.incremental style="font-size: 35px;"}
- This section covers developing an array-based implementation of the bag interface, called __ArrayBag__
- The design and implementation of the class consists of two steps:
    - Choose an appropriate data structure to contain the collection’s items and determine any other data that might be needed to represent the state of the collection (these data are assigned to instance variables in the `__init__ method`)
    - Complete the code for the methods specified in the interface
:::

## ArrayBag implementation: 
:::{.incremental style="font-size: 35px;"}
- Step 1: Choose and Initialize the Data Structures
    - An array-based implementation
        - Each object of type ArrayBag contains an array of the items in the bag
        - Can be an instance of the `Array` class or another array-based collection, such as Python’s list type
    - After initializing the two instance variables, the `__init__` method must deal with the possibility that its caller has provided a source collection parameter:
        - If that is the case, all the data in the source collection must be added to the new `ArrayBag` object

:::

## ArrayBag implementation: 
:::{.incremental style="font-size:"}
- Step 1: Choose and Initialize the Data Structures

    - The code for this part of the design is easy to create
        - You can make a copy of the bag interface file, `baginterface.py`, and rename it to `arraybag.py`
        - You then add an import statement for the array, rename the class to `ArrayBag`, add a class variable for the default capacity, and complete the `__init__` method
:::


## ArrayBag implementation: 

- Step 1: Choose and Initialize the Data Structures
```{.python}
"""
File: arraybag.py
"""
 
from arrays import Array
 
class ArrayBag(object):
"""An array-based bag implementation."""
 
    # Class variable
    DEFAULT_CAPACITY = 10
     
    # Constructor
    def __init__(self, sourceCollection = None):
        """Sets the initial state of self, which includes the
        contents of sourceCollection, if it’s present."""
        self.items = Array(ArrayBag.DEFAULT_CAPACITY)
        self.size = 0
        if sourceCollection:
            for item in sourceCollection:
                self.add(item)

```


## Complete the Easy Methods
:::{.smaller style="font-size:34px;"}
- Step 2:
    - Simplest methods in this interface: `IsEmpty`, _`len_`, `clear`, and `add`

```{.python}
# Accessor methods
def isEmpty(self):
    """Returns True if len(self) == 0, or False otherwise."""
    return len(self) == 0
     
def __len__(self):
    """Returns the number of items in self."""
    return self.size
 
# Mutator methods
def clear(self):
    """Makes self become empty."""
    self.size = 0
    self.items = Array(ArrayBag.DEFAULT_CAPACITY)
 
def add(self, item):
    """Adds item to self."""
    # Check array memory here and increase it if necessary
    self.items[len(self)] = item
    self.size += 1

```
:::


## Complete the Easy Methods
:::{.smaller style="font-size:34px;"}
- Step 2:

    - You should call a method or function on `self` to get something done within a class definition, whenever possible
    - For example,
        - Whenever you need to use the logical size of the bag within a class definition, run `len(self)` instead of referring directly to the instance variable `self.size`
    - The increment of size in the `add` method
        - Requires you to make the variable the target of the assignment; so you cannot avoid referring to it at that point
    - The `add` method places the new item at the logical end of the array
:::


## Complete the Iterator 
:::{.smaller style="font-size:34px;"}
- Step 3:

    - The new `__iter__` method maintains a cursor that allows it to navigate through a sequence of objects:
        - The caller’s for loop drives this process
    - On each pass through the calling for loop,
        - The item at the cursor is yielded to the caller, and then the cursor is advanced to the next object in the sequence
        - When the cursor reaches the length of the bag, the `__iter__` method’s __while__ loop terminates
        - Which in turn terminates the calling for loop
:::

:::{.notes}
The `__iter__` method in the `ArrayBag` class is responsible for making the bag iterable, so you can use it in a for loop. Inside this method, a cursor (usually an integer index) is initialized to 0. The method then enters a while loop that continues as long as the cursor is less than the logical size of the bag (`len(self)`). On each iteration, the item at the current cursor position is yielded to the caller, and the cursor is incremented by 1. When the cursor reaches the size of the bag, the while loop terminates, which also ends the iteration in the calling for loop.

def __iter__(self):
    """Supports iteration over a view of self."""
    cursor = 0
    while cursor < len(self):
        yield self.items[cursor]
        cursor += 1
:::


## Complete the Iterator 
:::{.smaller style="font-size:34px;"}

```{.python}
def __iter__(self):
    """Supports iteration over a view of self."""
    cursor = 0
    while cursor < len(self):
        yield self.items[cursor]
        cursor += 1

```
- The `yield` keyword in Python is used in a function to make it a generator.
- In this context, `yield` allows you to use the object in a `for` loop, and each iteration retrieves the next item from the collection.

:::
:::{.notes}
The `yield` keyword in Python is used in a function to make it a generator. When the function is called, it returns an iterator object but does not execute the function body immediately. Each time `yield` is encountered, the function's state is saved, and the yielded value is returned to the caller. The next time the iterator is advanced (e.g., by a for loop), execution resumes right after the last `yield`. This allows you to produce a sequence of values over time, rather than computing them all at once and sending them back in a list.

In the context of the `__iter__` method, `yield` is used to return each item in the collection one at a time, making the object iterable. For example:

def __iter__(self):
    cursor = 0
    while cursor < len(self):
        yield self.items[cursor]
        cursor += 1

This allows you to use the object in a for loop, and each iteration retrieves the next item from the collection.
:::

## Complete the Methods That Use the Iterator 
- Step 3
    - The `__eq__` method follows the rules for the equality test discussed in Chapter 2
    - The `__add__` method follows the rules for the concatenation of two collections discussed in Chapter 2
    - The `__str__` method uses the `map` and `join` operations to build a string containing the string representations of the bag’s items

## Complete the Methods That Use the Iterator 
:::{.smaller style="font-size:35px;"}

```{.python}
def __str__(self):
    """Returns the string representation of self."""
    return "{" + ", ".join(map(str, self)) + "}"  
    # possible to use [] to wrap the collection instead of {} which is a set notation
 
def __add__(self, other):
    """Returns a new bag containing the contents
    of self and other."""
    result = ArrayBag(self)
    for item in other:
        result.add(item)
    return result
 
def __eq__(self, other):
    """Returns True if self equals other,
    or False otherwise."""
    if self is other: return True
    if type(self) != type(other) or \
        len(self) != len(other):
        return False
    for item in self:
        if self.count(item) != other.count(item):
            return False
    return True
```
:::
:::{.notes}


The line `return "{" + ", ".join(map(str, self)) + "}"` in the `__str__` method does not remove duplicates. It simply creates a string by converting each item in the bag to a string (using `map(str, self)`) and joining them with commas. The curly braces `{}` are used for display purposes to mimic set notation, but the underlying data structure is still a bag (multiset), so duplicates are included in the output. For example, if the bag contains `[1, 2, 2, 3]`, the string representation will be `{1, 2, 2, 3}`.

The expression map(str, self) applies the str function to each element in self.

`map` is a built-in Python function that takes a function and an iterable.
str is the function that converts its argument to a string.
self is typically an iterable (like a list or tuple) in this context.
So, map(str, self) returns an iterator where each item from self has been converted to a string.

Example:
```{.python}
numbers = [1, 2, 3]
result = map(str, numbers)
print(list(result))  # Output: ['1', '2', '3']
```
Gotcha:
map returns an iterator in Python 3, so you often need to wrap it with list() or another iterable consumer to see the results.

:::

## Complete the `remove` Method

- The `remove` method is the most challenging method to complete in the bag implementation
- To begin with, you must check the precondition and raise an exception if it is violated
- Then you must search the underlying array for the target item
- Finally, you must shift the items in the array to the left to close the hole left by the removed item:
    - Decrement the bag’s size by one
    - Resize the array if necessary

## Complete the `remove` Method
```{.python}
def remove(self, item):
    """Precondition: item is in self.
    Raises: KeyError if item in not in self.
    postcondition: item is removed from self."""
    # 1. check precondition and raise an exception if necessary
    if not item in self:
        raise KeyError(str(item) + " not in bag")
    # 2. Search for index of target item
    targetIndex = 0
    for targetItem in self:
        if targetItem == item:
            break
        targetIndex += 1
    # 3. Shift items to the right of target left by one position
    for i in range(targetIndex, len(self) - 1):
        self.items[i] = self.items[i + 1]
    # 4. Decrement logical size
    self.size -= 1
    # 5. Check array memory here and decrease it if necessary

```

<!--
## Inserting at Any Position 
:::{.smaller style="font-size: 30px;"}
- Inserting an item between two items in a linked structure
    - ![](../images/insertAnyposition.png){style="width:70%"}
:::

## Removing at Any Position 

- The removal of the ith item from a linked structure has three cases:
    - ***i <= 0***—You use the code to remove the first item
    - ***0 < i < n***—You search for the node at position i – 1, as in insertion, and remove the following node
    - ***i >= n***—You remove the last node

## Removing at Any Position   
```{.python}
# Assumes that the linked structure has at least one item
if index <= 0 or head.next is None:
    removedItem = head.data
    head = head.next
    return removedItem
else:
    # Search for node at position index - 1 or
    # the next to last position
    probe = head
    while index > 1 and probe.next.next != None:
        probe = probe.next
        index -= 1
    removedItem = probe.next.data
    probe.next = probe.next.next
return removedItem

```

## Removing at Any Position 
- Removing an item between two items in a linked structure
    - ![](../images/removingAnyposition.png){style="width:50%"}


## Complexity Trade-Off: Singly Linked Structures
:::{.smaller style="font-size:23px;"}
- The Running Times of Operations on Singly Linked Structures

| Operation                | Running Time |
|--------------------------|-------------|
| Access (by position)     | O(n)        |
| Search (by value)        | O(n)        |
| Insertion at beginning   | O(1)        |
| Insertion at end         | O(n)        |
| Insertion at position i  | O(n)        |
| Removal at beginning     | O(1)        |
| Removal at end           | O(n)        |
| Removal at position i    | O(n)        |

- **Access/Search:** Must traverse from the head to the desired node.
- **Insert/Remove at beginning:** Only requires updating the head pointer.
- **Insert/Remove at end or position i:** Requires traversal to the appropriate node.
:::

## A Circular Linked Structure with a Dummy Header Node 
:::{.smaller style="font-size: 28px;"}
- The insertion and the removal of the first node are special cases of the insert ith and remove ith operations on singly linked structures:
    - These cases are special because the head pointer must be reset
- You can simplify these operations by using a circular linked structure with a dummy header node:
- A circular linked structure with a dummy header node is a variation of a linked list where:

    - The list is circular: the last node points back to the first node (or, more precisely, to the dummy header node).
    - There is a special node at the start called the dummy header node, which does not store user data. It simplifies edge cases (like insertions and deletions at the head or tail).


:::

## A Circular Linked Structure with a Dummy Header Node 
:::{.smaller style="font-size: 30px;"}
- A circular linked structure contains a link from the last node back to the first node in the structure
    - ![](../images/circularEmpty.png){style="width:40%;"}
- Key Features:

    - The dummy header node’s next pointer always points to the first real node (or to itself if the list is empty).
    - The last real node’s next pointer points back to the dummy header node, making the structure circular.
:::

## Relevance of Dommy Header Node
:::{.smaller style="font-size: 30px;"}
- Why use it?

    - Simplifies code for insertion and deletion, as you never have to check for None or handle empty list cases separately.
    - Traversal can start at header.next and continue until you reach the header again.
        - This mean `head link` is always pointed to the header 

- Why keep a tail pointer?

    - The tail pointer allows constant-time (O(1)) access to the last node.
    - Without it, inserting at the end or removing the last node would require traversing the entire list (O(n)).
    - In circular lists with a dummy header, the tail pointer is especially useful for efficient end operations, even though the structure is circular.
:::    


## A Circular Linked Structure with a Dummy Header Node 

```{.python}
class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

class CircularLinkedList:
    def __init__(self):
        # Create a dummy header node that points to itself
        self.header = Node()
        self.header.next = self.header
        self.tail = self.header 

    def insert(self, data):
        # Insert new node at the end (before header)
        new_node = Node(data, self.header)
        probe = self.header
        while probe.next != self.header:
            probe = probe.next
        probe.next = new_node
        self.tail = new_node

    def remove(self, data):
        # Remove first node with matching data
        probe = self.header
        while probe.next != self.header and probe.next.data != data:
            probe = probe.next
        if probe.next != self.header:
            to_remove = probe.next
            probe.next = to_remove.next
            # If removing the tail, update tail
            if to_remove == self.tail:
                if probe == self.header:
                    # List is now empty
                    self.tail = self.header
                else:
                    self.tail = probe

    def print_last(self):
        if self.tail == self.header:
            print("List is empty")
        else:
            print(self.tail.data)

            
clist = CircularLinkedList()
clist.insert(10)
clist.insert(20)
clist.insert(30)
clist.insert(50)
clist.insert(60)
clist.remove(60)
clist.print_last()

```



# Next week Reading:
- FDS - Lambert 
    - Chapters 5 & 6 -->